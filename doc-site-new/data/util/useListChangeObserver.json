{
  "declaration": {
    "id": 704,
    "name": "useListChangeObserver",
    "kind": 64,
    "kindString": "Function",
    "flags": {},
    "originalName": "default",
    "sources": [
      {
        "fileName": "js-packages/@prestojs/util/src/useListChangeObserver.ts",
        "line": 121,
        "character": 24
      }
    ],
    "signatures": [
      {
        "id": 705,
        "name": "useListChangeObserver",
        "kind": 4096,
        "kindString": "Call signature",
        "flags": {},
        "comment": {
          "shortText": "Call a function whenever values in a list change. This differs from `useChangeObserver` by\nallowing you to choose what changes you get (additions, updates, deletions) and to be passed the\nchanged items in the callback. In order to achieve this each item in the array needs to have a\nunique ID which is obtained by calling the `options.getId` function. The default implementation will\nlook for a `_key` or `id` property and return this, otherwise it return the value as is. This default\nimplementation is compatible with [ViewModel](doc:viewModelFactory) so you can pass lists of\nrecords returned from [useViewModelCache](doc:useViewModelCache).",
          "text": "```jsx\nexport default function UserListView() {\n  const { data, revalidate, isValidating } = useEndpoint(User.endpoints.list);\n  // Refetch data whenever underlying cache changes\n  const allRecords = useViewModelCache(User, cache => cache.getAll(fieldList));\n  // NOTE: Usually you don't want multiple useListChangeObserver's on the exact same\n  // subset of data as you will trigger redundant ajax queries.\n  // if a record is updated & saved elsewhere, then useViewModelCache will return new\n  // data which triggers useListChangeObserver. We still want useListChangeObserver()\n  // to trigger the useEndpoint() revalidate because that record update may have changed the\n  // order of records or caused it to [no longer] appear in a filtered list of data.\n  // Also note that we pass false while data is being fetched from the backend\n  useListChangeObserver(!isValidating && allRecords, revalidate);\n  return <ListView records={data} />;\n}\n```\n",
          "returns": "No return value\n",
          "tags": [
            {
              "tag": "extract-docs",
              "text": "\n"
            }
          ],
          "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\",\n      a: \"a\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"Call a function whenever values in a list change. This differs from \", _jsx(_components.code, {\n        children: \"useChangeObserver\"\n      }), \" by\\nallowing you to choose what changes you get (additions, updates, deletions) and to be passed the\\nchanged items in the callback. In order to achieve this each item in the array needs to have a\\nunique ID which is obtained by calling the \", _jsx(_components.code, {\n        children: \"options.getId\"\n      }), \" function. The default implementation will\\nlook for a \", _jsx(_components.code, {\n        children: \"_key\"\n      }), \" or \", _jsx(_components.code, {\n        children: \"id\"\n      }), \" property and return this, otherwise it return the value as is. This default\\nimplementation is compatible with \", _jsx(_components.a, {\n        href: \"/docs/viewmodel/viewModelFactory\",\n        children: \"ViewModel\"\n      }), \" so you can pass lists of\\nrecords returned from \", _jsx(_components.a, {\n        href: \"/docs/viewmodel/useViewModelCache\",\n        children: \"useViewModelCache\"\n      }), \".\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
          "textMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      pre: \"pre\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-jsx\",\n        children: \"export default function UserListView() {\\n  const { data, revalidate, isValidating } = useEndpoint(User.endpoints.list);\\n  // Refetch data whenever underlying cache changes\\n  const allRecords = useViewModelCache(User, cache => cache.getAll(fieldList));\\n  // NOTE: Usually you don't want multiple useListChangeObserver's on the exact same\\n  // subset of data as you will trigger redundant ajax queries.\\n  // if a record is updated & saved elsewhere, then useViewModelCache will return new\\n  // data which triggers useListChangeObserver. We still want useListChangeObserver()\\n  // to trigger the useEndpoint() revalidate because that record update may have changed the\\n  // order of records or caused it to [no longer] appear in a filtered list of data.\\n  // Also note that we pass false while data is being fetched from the backend\\n  useListChangeObserver(!isValidating && allRecords, revalidate);\\n  return <ListView records={data} />;\\n}\\n\"\n      })\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
          "returnsMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\"\n    }, _provideComponents(), props.components);\n    return _jsx(_components.p, {\n      children: \"No return value\"\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
        },
        "typeParameter": [
          {
            "id": 706,
            "name": "T",
            "kind": 131072,
            "kindString": "Type parameter",
            "flags": {},
            "type": {
              "type": "array",
              "elementType": {
                "type": "intrinsic",
                "name": "any"
              }
            },
            "anchorId": "T",
            "docFlags": {},
            "tagsByName": {}
          }
        ],
        "parameters": [
          {
            "id": 707,
            "name": "value",
            "kind": 32768,
            "kindString": "Parameter",
            "flags": {},
            "comment": {
              "shortText": "An array of values to monitor for changes. A falsey value can be passed to disable\nchecks. This is the same as passing `options.disabled`. This is convenient for cases where no value\nis available yet (eg. when waiting for initial response from an API endpoint)",
              "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"An array of values to monitor for changes. A falsey value can be passed to disable\\nchecks. This is the same as passing \", _jsx(_components.code, {\n        children: \"options.disabled\"\n      }), \". This is convenient for cases where no value\\nis available yet (eg. when waiting for initial response from an API endpoint)\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
            },
            "type": {
              "type": "union",
              "types": [
                {
                  "type": "intrinsic",
                  "name": "undefined"
                },
                {
                  "type": "literal",
                  "value": null
                },
                {
                  "type": "literal",
                  "value": false
                },
                {
                  "type": "reference",
                  "id": 706,
                  "name": "T"
                }
              ]
            },
            "anchorId": "value",
            "docFlags": {},
            "tagsByName": {}
          },
          {
            "id": 708,
            "name": "onChange",
            "kind": 32768,
            "kindString": "Parameter",
            "flags": {},
            "comment": {
              "shortText": "A method that will be called on any changes. This is passed an object of changes in the form:\n\n```\n{\n    ADD: [...],\n    UPDATE: [[<prev value>, <updated value>]...],\n    DELETE: [...],\n}\n```\nEach change type (ADD, UPDATE, DELETE) will be `false` if no value has changed.\n\nThe last and next list of records are also passed.\n",
              "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      pre: \"pre\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"A method that will be called on any changes. This is passed an object of changes in the form:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"{\\n    ADD: [...],\\n    UPDATE: [[<prev value>, <updated value>]...],\\n    DELETE: [...],\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Each change type (ADD, UPDATE, DELETE) will be \", _jsx(_components.code, {\n          children: \"false\"\n        }), \" if no value has changed.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The last and next list of records are also passed.\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
            },
            "type": {
              "type": "reference",
              "typeArguments": [
                {
                  "type": "reference",
                  "id": 706,
                  "name": "T"
                }
              ],
              "name": "OnChange"
            },
            "anchorId": "onChange",
            "docFlags": {},
            "tagsByName": {}
          },
          {
            "id": 709,
            "name": "options",
            "kind": 32768,
            "kindString": "Parameter",
            "flags": {
              "isOptional": true
            },
            "type": {
              "type": "reference",
              "typeArguments": [
                {
                  "type": "reference",
                  "id": 706,
                  "name": "T"
                }
              ],
              "name": "ListChangeObserverOptions"
            },
            "anchorId": "options",
            "docFlags": {},
            "tagsByName": {}
          }
        ],
        "type": {
          "type": "intrinsic",
          "name": "void"
        },
        "anchorId": "useListChangeObserver",
        "docFlags": {},
        "tagsByName": {
          "extract-docs": ""
        }
      }
    ],
    "docFlags": {},
    "tagsByName": {
      "extract-docs": ""
    },
    "slug": "util/useListChangeObserver"
  },
  "references": {},
  "meta": {
    "packageName": "util",
    "permaLink": "useListChangeObserver",
    "menuGroup": "default"
  }
}