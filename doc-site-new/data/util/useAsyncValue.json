{
  "node": {
    "id": 664,
    "name": "useAsyncValue",
    "kind": 64,
    "kindString": "Function",
    "flags": {},
    "originalName": "default",
    "sources": [
      {
        "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
        "line": 148,
        "character": 24
      }
    ],
    "signatures": [
      {
        "id": 665,
        "name": "useAsyncValue",
        "kind": 4096,
        "kindString": "Call signature",
        "flags": {},
        "comment": {
          "shortText": "Resolve a value from an id using an async function.",
          "text": "For the specified `id` the `resolve` function will be called and should\nreturn the value for the specified id.\n\nIf `existingValues` is provided this will be consulted first before calling\n`resolve`. This is useful when you have a list of values that may or\nmay not have the data you care about. If it's there then the value will\nbe returned immediately.\n\nFor multiple values see documentation below.\n",
          "tags": [
            {
              "tag": "extract-docs",
              "text": "\n"
            }
          ],
          "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\"\n    }, _provideComponents(), props.components);\n    return _jsx(_components.p, {\n      children: \"Resolve a value from an id using an async function.\"\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
          "textMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"For the specified \", _jsx(_components.code, {\n          children: \"id\"\n        }), \" the \", _jsx(_components.code, {\n          children: \"resolve\"\n        }), \" function will be called and should\\nreturn the value for the specified id.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If \", _jsx(_components.code, {\n          children: \"existingValues\"\n        }), \" is provided this will be consulted first before calling\\n\", _jsx(_components.code, {\n          children: \"resolve\"\n        }), \". This is useful when you have a list of values that may or\\nmay not have the data you care about. If it's there then the value will\\nbe returned immediately.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"For multiple values see documentation below.\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
        },
        "typeParameter": [
          {
            "id": 666,
            "name": "T",
            "kind": 131072,
            "kindString": "Type parameter",
            "flags": {},
            "docFlags": {},
            "tagsByName": {}
          },
          {
            "id": 667,
            "name": "U",
            "kind": 131072,
            "kindString": "Type parameter",
            "flags": {},
            "type": {
              "type": "reference",
              "id": 54,
              "name": "Id"
            },
            "docFlags": {},
            "tagsByName": {}
          }
        ],
        "parameters": [
          {
            "id": 668,
            "name": "props",
            "kind": 32768,
            "kindString": "Parameter",
            "flags": {},
            "type": {
              "type": "reference",
              "id": 637,
              "typeArguments": [
                {
                  "type": "reference",
                  "id": 666,
                  "name": "T"
                },
                {
                  "type": "reference",
                  "id": 667,
                  "name": "U"
                }
              ],
              "name": "UseAsyncValuePropsSingle"
            },
            "docFlags": {},
            "tagsByName": {}
          }
        ],
        "type": {
          "type": "reference",
          "id": 653,
          "typeArguments": [
            {
              "type": "reference",
              "id": 666,
              "name": "T"
            }
          ],
          "name": "UseAsyncValueReturn"
        },
        "docFlags": {},
        "tagsByName": {
          "extract-docs": ""
        }
      },
      {
        "id": 669,
        "name": "useAsyncValue",
        "kind": 4096,
        "kindString": "Call signature",
        "flags": {},
        "comment": {
          "shortText": "Resolve values from an array of ids using an async function.",
          "text": "For the specified array of `ids` the `resolve` function will be called\nand should return an array of the same size with each entry being the resolved\nvalue for the corresponding id.\n\nIf `existingValues` is provided this will be consulted first before calling\n`resolve`. This is useful when you have a list of values that may or\nmay not have the data you care about. If it's there then the values will\nbe returned immediately. Note that if any of the ids are missing from\n`existingValues` then it will be ignored and a call to `resolve` will be made\nrequesting values for all `ids`.\n",
          "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\"\n    }, _provideComponents(), props.components);\n    return _jsx(_components.p, {\n      children: \"Resolve values from an array of ids using an async function.\"\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
          "textMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"For the specified array of \", _jsx(_components.code, {\n          children: \"ids\"\n        }), \" the \", _jsx(_components.code, {\n          children: \"resolve\"\n        }), \" function will be called\\nand should return an array of the same size with each entry being the resolved\\nvalue for the corresponding id.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If \", _jsx(_components.code, {\n          children: \"existingValues\"\n        }), \" is provided this will be consulted first before calling\\n\", _jsx(_components.code, {\n          children: \"resolve\"\n        }), \". This is useful when you have a list of values that may or\\nmay not have the data you care about. If it's there then the values will\\nbe returned immediately. Note that if any of the ids are missing from\\n\", _jsx(_components.code, {\n          children: \"existingValues\"\n        }), \" then it will be ignored and a call to \", _jsx(_components.code, {\n          children: \"resolve\"\n        }), \" will be made\\nrequesting values for all \", _jsx(_components.code, {\n          children: \"ids\"\n        }), \".\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
        },
        "typeParameter": [
          {
            "id": 670,
            "name": "T",
            "kind": 131072,
            "kindString": "Type parameter",
            "flags": {},
            "docFlags": {},
            "tagsByName": {}
          },
          {
            "id": 671,
            "name": "U",
            "kind": 131072,
            "kindString": "Type parameter",
            "flags": {},
            "type": {
              "type": "reference",
              "id": 54,
              "name": "Id"
            },
            "docFlags": {},
            "tagsByName": {}
          }
        ],
        "parameters": [
          {
            "id": 672,
            "name": "props",
            "kind": 32768,
            "kindString": "Parameter",
            "flags": {},
            "type": {
              "type": "reference",
              "id": 645,
              "typeArguments": [
                {
                  "type": "reference",
                  "id": 670,
                  "name": "T"
                },
                {
                  "type": "reference",
                  "id": 671,
                  "name": "U"
                }
              ],
              "name": "UseAsyncValuePropsMulti"
            },
            "docFlags": {},
            "tagsByName": {}
          }
        ],
        "type": {
          "type": "reference",
          "id": 653,
          "typeArguments": [
            {
              "type": "array",
              "elementType": {
                "type": "reference",
                "id": 670,
                "name": "T"
              }
            }
          ],
          "name": "UseAsyncValueReturn"
        },
        "docFlags": {},
        "tagsByName": {}
      }
    ],
    "docFlags": {},
    "tagsByName": {}
  },
  "references": {
    "54": {
      "id": 54,
      "name": "Id",
      "kind": 4194304,
      "kindString": "Type alias",
      "flags": {},
      "sources": [
        {
          "fileName": "js-packages/@prestojs/util/src/identifiable.ts",
          "line": 3,
          "character": 12
        }
      ],
      "type": {
        "type": "union",
        "types": [
          {
            "type": "reference",
            "id": 1266,
            "name": "SingleId"
          },
          {
            "type": "reference",
            "id": 1267,
            "name": "CompoundId"
          }
        ]
      },
      "docFlags": {},
      "tagsByName": {}
    },
    "637": {
      "id": 637,
      "name": "UseAsyncValuePropsSingle",
      "kind": 4194304,
      "kindString": "Type alias",
      "flags": {},
      "comment": {
        "tags": [
          {
            "tag": "expand-properties",
            "text": "\n"
          }
        ]
      },
      "sources": [
        {
          "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
          "line": 61,
          "character": 12
        }
      ],
      "typeParameter": [
        {
          "id": 643,
          "name": "T",
          "kind": 131072,
          "kindString": "Type parameter",
          "flags": {},
          "docFlags": {},
          "tagsByName": {}
        },
        {
          "id": 644,
          "name": "U",
          "kind": 131072,
          "kindString": "Type parameter",
          "flags": {},
          "type": {
            "type": "reference",
            "id": 54,
            "name": "Id"
          },
          "docFlags": {},
          "tagsByName": {}
        }
      ],
      "type": {
        "type": "intersection",
        "types": [
          {
            "type": "reference",
            "id": 1787,
            "typeArguments": [
              {
                "type": "reference",
                "id": 643,
                "name": "T"
              },
              {
                "type": "reference",
                "id": 644,
                "name": "U"
              }
            ],
            "name": "CommonProps"
          },
          {
            "type": "reflection",
            "declaration": {
              "id": 638,
              "name": "__type",
              "kind": 65536,
              "kindString": "Type literal",
              "flags": {},
              "children": [
                {
                  "id": 639,
                  "name": "id",
                  "kind": 1024,
                  "kindString": "Property",
                  "flags": {},
                  "comment": {
                    "shortText": "Single `id` for value to fetch or null if nothing yet to resolve.",
                    "text": "If you need to resolve multiple values use the other form documented\nbelow passing `ids` instead.\n",
                    "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"Single \", _jsx(_components.code, {\n        children: \"id\"\n      }), \" for value to fetch or null if nothing yet to resolve.\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
                    "textMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"If you need to resolve multiple values use the other form documented\\nbelow passing \", _jsx(_components.code, {\n        children: \"ids\"\n      }), \" instead.\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
                  },
                  "sources": [
                    {
                      "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                      "line": 68,
                      "character": 4
                    }
                  ],
                  "type": {
                    "type": "union",
                    "types": [
                      {
                        "type": "reference",
                        "id": 644,
                        "name": "U"
                      },
                      {
                        "type": "literal",
                        "value": null
                      }
                    ]
                  },
                  "docFlags": {},
                  "tagsByName": {}
                },
                {
                  "id": 640,
                  "name": "resolve",
                  "kind": 2048,
                  "kindString": "Method",
                  "flags": {},
                  "sources": [
                    {
                      "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                      "line": 77,
                      "character": 4
                    }
                  ],
                  "signatures": [
                    {
                      "id": 641,
                      "name": "resolve",
                      "kind": 4096,
                      "kindString": "Call signature",
                      "flags": {},
                      "comment": {
                        "shortText": "Resolve the value for the provided ID. Function is passed a single parameter\nbeing `id`.",
                        "text": "Note that when `trigger` is `DEEP` changes to this function will cause it\nto be called again so you must memoize it (eg. with `useCallback`) if it's\ndefined in your component or hook.\n",
                        "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"Resolve the value for the provided ID. Function is passed a single parameter\\nbeing \", _jsx(_components.code, {\n        children: \"id\"\n      }), \".\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
                        "textMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"Note that when \", _jsx(_components.code, {\n        children: \"trigger\"\n      }), \" is \", _jsx(_components.code, {\n        children: \"DEEP\"\n      }), \" changes to this function will cause it\\nto be called again so you must memoize it (eg. with \", _jsx(_components.code, {\n        children: \"useCallback\"\n      }), \") if it's\\ndefined in your component or hook.\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
                      },
                      "parameters": [
                        {
                          "id": 642,
                          "name": "id",
                          "kind": 32768,
                          "kindString": "Parameter",
                          "flags": {},
                          "type": {
                            "type": "reference",
                            "id": 644,
                            "name": "U"
                          },
                          "docFlags": {},
                          "tagsByName": {}
                        }
                      ],
                      "type": {
                        "type": "reference",
                        "typeArguments": [
                          {
                            "type": "reference",
                            "id": 643,
                            "name": "T"
                          }
                        ],
                        "qualifiedName": "Promise",
                        "package": "typescript",
                        "name": "Promise"
                      },
                      "docFlags": {},
                      "tagsByName": {}
                    }
                  ],
                  "docFlags": {},
                  "tagsByName": {}
                }
              ],
              "groups": [
                {
                  "title": "Properties",
                  "kind": 1024,
                  "children": [639]
                },
                {
                  "title": "Methods",
                  "kind": 2048,
                  "children": [640]
                }
              ],
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 61,
                  "character": 76
                }
              ],
              "docFlags": {},
              "tagsByName": {}
            }
          }
        ]
      },
      "docFlags": {
        "expandProperties": true
      },
      "tagsByName": {
        "expand-properties": ""
      }
    },
    "645": {
      "id": 645,
      "name": "UseAsyncValuePropsMulti",
      "kind": 4194304,
      "kindString": "Type alias",
      "flags": {},
      "comment": {
        "tags": [
          {
            "tag": "expand-properties",
            "text": "\n"
          }
        ]
      },
      "sources": [
        {
          "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
          "line": 83,
          "character": 12
        }
      ],
      "typeParameter": [
        {
          "id": 651,
          "name": "T",
          "kind": 131072,
          "kindString": "Type parameter",
          "flags": {},
          "docFlags": {},
          "tagsByName": {}
        },
        {
          "id": 652,
          "name": "U",
          "kind": 131072,
          "kindString": "Type parameter",
          "flags": {},
          "type": {
            "type": "reference",
            "id": 54,
            "name": "Id"
          },
          "docFlags": {},
          "tagsByName": {}
        }
      ],
      "type": {
        "type": "intersection",
        "types": [
          {
            "type": "reference",
            "id": 1787,
            "typeArguments": [
              {
                "type": "reference",
                "id": 651,
                "name": "T"
              },
              {
                "type": "reference",
                "id": 652,
                "name": "U"
              }
            ],
            "name": "CommonProps"
          },
          {
            "type": "reflection",
            "declaration": {
              "id": 646,
              "name": "__type",
              "kind": 65536,
              "kindString": "Type literal",
              "flags": {},
              "children": [
                {
                  "id": 647,
                  "name": "ids",
                  "kind": 1024,
                  "kindString": "Property",
                  "flags": {},
                  "comment": {
                    "shortText": "Array of ids to resolve values for or null if nothing yet to resolve",
                    "text": "If you need to resolve a single value use the other form documented above\npassing `id` instead\n",
                    "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\"\n    }, _provideComponents(), props.components);\n    return _jsx(_components.p, {\n      children: \"Array of ids to resolve values for or null if nothing yet to resolve\"\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
                    "textMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"If you need to resolve a single value use the other form documented above\\npassing \", _jsx(_components.code, {\n        children: \"id\"\n      }), \" instead\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
                  },
                  "sources": [
                    {
                      "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                      "line": 90,
                      "character": 4
                    }
                  ],
                  "type": {
                    "type": "union",
                    "types": [
                      {
                        "type": "array",
                        "elementType": {
                          "type": "reference",
                          "id": 652,
                          "name": "U"
                        }
                      },
                      {
                        "type": "literal",
                        "value": null
                      }
                    ]
                  },
                  "docFlags": {},
                  "tagsByName": {}
                },
                {
                  "id": 648,
                  "name": "resolve",
                  "kind": 2048,
                  "kindString": "Method",
                  "flags": {},
                  "sources": [
                    {
                      "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                      "line": 95,
                      "character": 4
                    }
                  ],
                  "signatures": [
                    {
                      "id": 649,
                      "name": "resolve",
                      "kind": 4096,
                      "kindString": "Call signature",
                      "flags": {},
                      "comment": {
                        "shortText": "Resolve the value for the provided IDs. Function is passed a single parameter\nbeing `ids`",
                        "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"Resolve the value for the provided IDs. Function is passed a single parameter\\nbeing \", _jsx(_components.code, {\n        children: \"ids\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
                      },
                      "parameters": [
                        {
                          "id": 650,
                          "name": "ids",
                          "kind": 32768,
                          "kindString": "Parameter",
                          "flags": {},
                          "type": {
                            "type": "array",
                            "elementType": {
                              "type": "reference",
                              "id": 652,
                              "name": "U"
                            }
                          },
                          "docFlags": {},
                          "tagsByName": {}
                        }
                      ],
                      "type": {
                        "type": "reference",
                        "typeArguments": [
                          {
                            "type": "array",
                            "elementType": {
                              "type": "reference",
                              "id": 651,
                              "name": "T"
                            }
                          }
                        ],
                        "qualifiedName": "Promise",
                        "package": "typescript",
                        "name": "Promise"
                      },
                      "docFlags": {},
                      "tagsByName": {}
                    }
                  ],
                  "docFlags": {},
                  "tagsByName": {}
                }
              ],
              "groups": [
                {
                  "title": "Properties",
                  "kind": 1024,
                  "children": [647]
                },
                {
                  "title": "Methods",
                  "kind": 2048,
                  "children": [648]
                }
              ],
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 83,
                  "character": 75
                }
              ],
              "docFlags": {},
              "tagsByName": {}
            }
          }
        ]
      },
      "docFlags": {
        "expandProperties": true
      },
      "tagsByName": {
        "expand-properties": ""
      }
    },
    "653": {
      "id": 653,
      "name": "UseAsyncValueReturn",
      "kind": 4194304,
      "kindString": "Type alias",
      "flags": {},
      "sources": [
        {
          "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
          "line": 98,
          "character": 12
        }
      ],
      "typeParameter": [
        {
          "id": 663,
          "name": "T",
          "kind": 131072,
          "kindString": "Type parameter",
          "flags": {},
          "docFlags": {},
          "tagsByName": {}
        }
      ],
      "type": {
        "type": "reflection",
        "declaration": {
          "id": 654,
          "name": "__type",
          "kind": 65536,
          "kindString": "Type literal",
          "flags": {},
          "children": [
            {
              "id": 655,
              "name": "error",
              "kind": 1024,
              "kindString": "Property",
              "flags": {},
              "comment": {
                "shortText": "Set to the rejected value of the promise. Only one of `error` and `value` can be set. If\n`isLoading` is true consider this stale (ie. based on _previous_ props). This can be useful\nwhen you want the UI to show the previous value until the next value is ready.",
                "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\",\n      em: \"em\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"Set to the rejected value of the promise. Only one of \", _jsx(_components.code, {\n        children: \"error\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"value\"\n      }), \" can be set. If\\n\", _jsx(_components.code, {\n        children: \"isLoading\"\n      }), \" is true consider this stale (ie. based on \", _jsx(_components.em, {\n        children: \"previous\"\n      }), \" props). This can be useful\\nwhen you want the UI to show the previous value until the next value is ready.\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
              },
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 104,
                  "character": 4
                }
              ],
              "type": {
                "type": "union",
                "types": [
                  {
                    "type": "literal",
                    "value": null
                  },
                  {
                    "type": "reference",
                    "id": 1168,
                    "qualifiedName": "Error",
                    "package": "typescript",
                    "name": "Error"
                  }
                ]
              },
              "docFlags": {},
              "tagsByName": {}
            },
            {
              "id": 656,
              "name": "isLoading",
              "kind": 1024,
              "kindString": "Property",
              "flags": {},
              "comment": {
                "shortText": "True while `resolve` call is in progress.",
                "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"True while \", _jsx(_components.code, {\n        children: \"resolve\"\n      }), \" call is in progress.\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
              },
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 108,
                  "character": 4
                }
              ],
              "type": {
                "type": "intrinsic",
                "name": "boolean"
              },
              "docFlags": {},
              "tagsByName": {}
            },
            {
              "id": 657,
              "name": "value",
              "kind": 1024,
              "kindString": "Property",
              "flags": {},
              "comment": {
                "shortText": "The resolved value",
                "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\"\n    }, _provideComponents(), props.components);\n    return _jsx(_components.p, {\n      children: \"The resolved value\"\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
              },
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 112,
                  "character": 4
                }
              ],
              "type": {
                "type": "union",
                "types": [
                  {
                    "type": "reference",
                    "id": 663,
                    "name": "T"
                  },
                  {
                    "type": "literal",
                    "value": null
                  }
                ]
              },
              "docFlags": {},
              "tagsByName": {}
            },
            {
              "id": 661,
              "name": "reset",
              "kind": 2048,
              "kindString": "Method",
              "flags": {},
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 130,
                  "character": 4
                }
              ],
              "signatures": [
                {
                  "id": 662,
                  "name": "reset",
                  "kind": 4096,
                  "kindString": "Call signature",
                  "flags": {},
                  "comment": {
                    "shortText": "When called will set both result and error to null. Will not immediately trigger\na call to the action but subsequent changes to query or paginator will according\nto the value of `trigger`.",
                    "text": "If value is found in `existingValues` then it will still be returned even if\nyou call `reset` - `reset` only clears values that are returned from `resolve`.\n",
                    "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"When called will set both result and error to null. Will not immediately trigger\\na call to the action but subsequent changes to query or paginator will according\\nto the value of \", _jsx(_components.code, {\n        children: \"trigger\"\n      }), \".\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
                    "textMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"If value is found in \", _jsx(_components.code, {\n        children: \"existingValues\"\n      }), \" then it will still be returned even if\\nyou call \", _jsx(_components.code, {\n        children: \"reset\"\n      }), \" - \", _jsx(_components.code, {\n        children: \"reset\"\n      }), \" only clears values that are returned from \", _jsx(_components.code, {\n        children: \"resolve\"\n      }), \".\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
                  },
                  "type": {
                    "type": "intrinsic",
                    "name": "void"
                  },
                  "docFlags": {},
                  "tagsByName": {}
                }
              ],
              "docFlags": {},
              "tagsByName": {}
            },
            {
              "id": 658,
              "name": "run",
              "kind": 2048,
              "kindString": "Method",
              "flags": {},
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 121,
                  "character": 4
                }
              ],
              "signatures": [
                {
                  "id": 659,
                  "name": "run",
                  "kind": 4096,
                  "kindString": "Call signature",
                  "flags": {},
                  "comment": {
                    "shortText": "A function to manually trigger the action. If `options.trigger` is `MANUAL`\ncalling this function is the only way to trigger the action.",
                    "text": "This function will return a promise that resolves/rejects to same value\nreturned by `execute`. If `accumulatePages` is set the value returned is\nthe accumulated value.\n",
                    "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"A function to manually trigger the action. If \", _jsx(_components.code, {\n        children: \"options.trigger\"\n      }), \" is \", _jsx(_components.code, {\n        children: \"MANUAL\"\n      }), \"\\ncalling this function is the only way to trigger the action.\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
                    "textMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"This function will return a promise that resolves/rejects to same value\\nreturned by \", _jsx(_components.code, {\n        children: \"execute\"\n      }), \". If \", _jsx(_components.code, {\n        children: \"accumulatePages\"\n      }), \" is set the value returned is\\nthe accumulated value.\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
                  },
                  "parameters": [
                    {
                      "id": 660,
                      "name": "args",
                      "kind": 32768,
                      "kindString": "Parameter",
                      "flags": {
                        "isRest": true
                      },
                      "type": {
                        "type": "array",
                        "elementType": {
                          "type": "intrinsic",
                          "name": "any"
                        }
                      },
                      "docFlags": {},
                      "tagsByName": {}
                    }
                  ],
                  "type": {
                    "type": "reference",
                    "typeArguments": [
                      {
                        "type": "intrinsic",
                        "name": "any"
                      }
                    ],
                    "qualifiedName": "Promise",
                    "package": "typescript",
                    "name": "Promise"
                  },
                  "docFlags": {},
                  "tagsByName": {}
                }
              ],
              "docFlags": {},
              "tagsByName": {}
            }
          ],
          "groups": [
            {
              "title": "Properties",
              "kind": 1024,
              "children": [655, 656, 657]
            },
            {
              "title": "Methods",
              "kind": 2048,
              "children": [661, 658]
            }
          ],
          "sources": [
            {
              "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
              "line": 98,
              "character": 37
            }
          ],
          "docFlags": {},
          "tagsByName": {}
        }
      },
      "docFlags": {},
      "tagsByName": {}
    },
    "1168": {
      "id": 1168,
      "name": "Error",
      "kind": 32,
      "kindString": "Variable",
      "flags": {
        "isExternal": true
      },
      "sources": [
        {
          "fileName": "node_modules/typescript/lib/lib.es5.d.ts",
          "line": 1033,
          "character": 12
        }
      ],
      "type": {
        "type": "reference",
        "qualifiedName": "ErrorConstructor",
        "package": "typescript",
        "name": "ErrorConstructor"
      },
      "extendedBy": [
        {
          "type": "reference",
          "id": 564,
          "name": "InvalidTimeError"
        }
      ],
      "docFlags": {},
      "tagsByName": {}
    },
    "1787": {
      "id": 1787,
      "name": "CommonProps",
      "kind": 4194304,
      "kindString": "Type alias",
      "flags": {},
      "sources": [
        {
          "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
          "line": 17,
          "character": 5
        }
      ],
      "typeParameter": [
        {
          "id": 1800,
          "name": "T",
          "kind": 131072,
          "kindString": "Type parameter",
          "flags": {},
          "docFlags": {},
          "tagsByName": {}
        },
        {
          "id": 1801,
          "name": "U",
          "kind": 131072,
          "kindString": "Type parameter",
          "flags": {},
          "type": {
            "type": "reference",
            "id": 54,
            "name": "Id"
          },
          "docFlags": {},
          "tagsByName": {}
        }
      ],
      "type": {
        "type": "reflection",
        "declaration": {
          "id": 1788,
          "name": "__type",
          "kind": 65536,
          "kindString": "Type literal",
          "flags": {},
          "children": [
            {
              "id": 1789,
              "name": "existingValues",
              "kind": 1024,
              "kindString": "Property",
              "flags": {
                "isOptional": true
              },
              "comment": {
                "shortText": "An optional array of existing values to try and find the value in.",
                "text": "If each item does not implement [Identifiable](doc:Identifiable) then you\nmust provide the `getId` function.\n\nYou can use this to avoid resolving data that already exists. If dealing with\nViewModel instances you can use it with [useViewModelCache](doc:useViewModelCache),\neg.\n\n```js\nconst existingValues = useViewModelCache(User, cache => cache.get(id, fieldNames));\nconst { value } = useAsyncValue({ id, existingValues, resolve: fetchUser });\n```\n",
                "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\"\n    }, _provideComponents(), props.components);\n    return _jsx(_components.p, {\n      children: \"An optional array of existing values to try and find the value in.\"\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
                "textMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      a: \"a\",\n      code: \"code\",\n      pre: \"pre\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"If each item does not implement \", _jsx(_components.a, {\n          href: \"doc:Identifiable\",\n          children: \"Identifiable\"\n        }), \" then you\\nmust provide the \", _jsx(_components.code, {\n          children: \"getId\"\n        }), \" function.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"You can use this to avoid resolving data that already exists. If dealing with\\nViewModel instances you can use it with \", _jsx(_components.a, {\n          href: \"doc:useViewModelCache\",\n          children: \"useViewModelCache\"\n        }), \",\\neg.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-js\",\n          children: \"const existingValues = useViewModelCache(User, cache => cache.get(id, fieldNames));\\nconst { value } = useAsyncValue({ id, existingValues, resolve: fetchUser });\\n\"\n        })\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
              },
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 33,
                  "character": 4
                }
              ],
              "type": {
                "type": "array",
                "elementType": {
                  "type": "reference",
                  "id": 1800,
                  "name": "T"
                }
              },
              "docFlags": {},
              "tagsByName": {}
            },
            {
              "id": 1793,
              "name": "trigger",
              "kind": 1024,
              "kindString": "Property",
              "flags": {
                "isOptional": true
              },
              "comment": {
                "shortText": "When to trigger the fetch. Defaults to `DEEP` which means whenever `id`\nor `ids` changed it will refetch if the value hasn't already been resolved.",
                "text": "If set to `MANUAL` nothing will happen until it changes to `DEEP`. You\ncan use this to defer execution until the value is required.\n",
                "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"When to trigger the fetch. Defaults to \", _jsx(_components.code, {\n        children: \"DEEP\"\n      }), \" which means whenever \", _jsx(_components.code, {\n        children: \"id\"\n      }), \"\\nor \", _jsx(_components.code, {\n        children: \"ids\"\n      }), \" changed it will refetch if the value hasn't already been resolved.\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
                "textMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"If set to \", _jsx(_components.code, {\n        children: \"MANUAL\"\n      }), \" nothing will happen until it changes to \", _jsx(_components.code, {\n        children: \"DEEP\"\n      }), \". You\\ncan use this to defer execution until the value is required.\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
              },
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 46,
                  "character": 4
                }
              ],
              "type": {
                "type": "union",
                "types": [
                  {
                    "type": "literal",
                    "value": "MANUAL"
                  },
                  {
                    "type": "literal",
                    "value": "DEEP"
                  }
                ]
              },
              "docFlags": {},
              "tagsByName": {}
            },
            {
              "id": 1790,
              "name": "getId",
              "kind": 2048,
              "kindString": "Method",
              "flags": {
                "isOptional": true
              },
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 38,
                  "character": 4
                }
              ],
              "signatures": [
                {
                  "id": 1791,
                  "name": "getId",
                  "kind": 4096,
                  "kindString": "Call signature",
                  "flags": {},
                  "comment": {
                    "shortText": "A function that returns a unique ID for each item in `existingValues`. Only\nrequired if each item does not implement [Identifiable](doc:Identifiable).",
                    "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\",\n      a: \"a\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"A function that returns a unique ID for each item in \", _jsx(_components.code, {\n        children: \"existingValues\"\n      }), \". Only\\nrequired if each item does not implement \", _jsx(_components.a, {\n        href: \"doc:Identifiable\",\n        children: \"Identifiable\"\n      }), \".\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
                  },
                  "parameters": [
                    {
                      "id": 1792,
                      "name": "item",
                      "kind": 32768,
                      "kindString": "Parameter",
                      "flags": {},
                      "type": {
                        "type": "reference",
                        "id": 1800,
                        "name": "T"
                      },
                      "docFlags": {},
                      "tagsByName": {}
                    }
                  ],
                  "type": {
                    "type": "reference",
                    "id": 1801,
                    "name": "U"
                  },
                  "docFlags": {},
                  "tagsByName": {}
                }
              ],
              "docFlags": {},
              "tagsByName": {}
            },
            {
              "id": 1797,
              "name": "onError",
              "kind": 2048,
              "kindString": "Method",
              "flags": {
                "isOptional": true
              },
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 55,
                  "character": 4
                }
              ],
              "signatures": [
                {
                  "id": 1798,
                  "name": "onError",
                  "kind": 4096,
                  "kindString": "Call signature",
                  "flags": {},
                  "comment": {
                    "shortText": "Called when `resolve` errors. Passed the error returned from `resolve`.",
                    "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"Called when \", _jsx(_components.code, {\n        children: \"resolve\"\n      }), \" errors. Passed the error returned from \", _jsx(_components.code, {\n        children: \"resolve\"\n      }), \".\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
                  },
                  "parameters": [
                    {
                      "id": 1799,
                      "name": "error",
                      "kind": 32768,
                      "kindString": "Parameter",
                      "flags": {},
                      "type": {
                        "type": "reference",
                        "id": 1168,
                        "qualifiedName": "Error",
                        "package": "typescript",
                        "name": "Error"
                      },
                      "docFlags": {},
                      "tagsByName": {}
                    }
                  ],
                  "type": {
                    "type": "intrinsic",
                    "name": "void"
                  },
                  "docFlags": {},
                  "tagsByName": {}
                }
              ],
              "docFlags": {},
              "tagsByName": {}
            },
            {
              "id": 1794,
              "name": "onSuccess",
              "kind": 2048,
              "kindString": "Method",
              "flags": {
                "isOptional": true
              },
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 51,
                  "character": 4
                }
              ],
              "signatures": [
                {
                  "id": 1795,
                  "name": "onSuccess",
                  "kind": 4096,
                  "kindString": "Call signature",
                  "flags": {},
                  "comment": {
                    "shortText": "Called when `resolve` resolves successfully. Is passed a single parameter which\nis the value returned from `resolve`",
                    "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"Called when \", _jsx(_components.code, {\n        children: \"resolve\"\n      }), \" resolves successfully. Is passed a single parameter which\\nis the value returned from \", _jsx(_components.code, {\n        children: \"resolve\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
                  },
                  "parameters": [
                    {
                      "id": 1796,
                      "name": "response",
                      "kind": 32768,
                      "kindString": "Parameter",
                      "flags": {},
                      "type": {
                        "type": "reference",
                        "id": 1800,
                        "name": "T"
                      },
                      "docFlags": {},
                      "tagsByName": {}
                    }
                  ],
                  "type": {
                    "type": "intrinsic",
                    "name": "void"
                  },
                  "docFlags": {},
                  "tagsByName": {}
                }
              ],
              "docFlags": {},
              "tagsByName": {}
            }
          ],
          "groups": [
            {
              "title": "Properties",
              "kind": 1024,
              "children": [1789, 1793]
            },
            {
              "title": "Methods",
              "kind": 2048,
              "children": [1790, 1797, 1794]
            }
          ],
          "sources": [
            {
              "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
              "line": 17,
              "character": 36
            }
          ],
          "docFlags": {},
          "tagsByName": {}
        }
      },
      "docFlags": {},
      "tagsByName": {}
    }
  },
  "meta": {
    "packageName": "util",
    "permaLink": "util/useAsyncValue",
    "menuGroup": "default"
  }
}
