{
  "declaration": {
    "id": 672,
    "name": "useAsyncValue",
    "kind": 64,
    "kindString": "Function",
    "flags": {},
    "originalName": "default",
    "sources": [
      {
        "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
        "line": 148,
        "character": 24
      }
    ],
    "signatures": [
      {
        "id": 673,
        "name": "useAsyncValue",
        "kind": 4096,
        "kindString": "Call signature",
        "flags": {},
        "comment": {
          "shortText": "Resolve a value from an id using an async function.",
          "text": "For the specified `id` the `resolve` function will be called and should\nreturn the value for the specified id.\n\nIf `existingValues` is provided this will be consulted first before calling\n`resolve`. This is useful when you have a list of values that may or\nmay not have the data you care about. If it's there then the value will\nbe returned immediately.\n\nFor multiple values see documentation below.\n",
          "tags": [
            {
              "tag": "extract-docs",
              "text": "\n"
            }
          ],
          "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\"\n    }, _provideComponents(), props.components);\n    return _jsx(_components.p, {\n      children: \"Resolve a value from an id using an async function.\"\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
          "textMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"For the specified \", _jsx(_components.code, {\n          children: \"id\"\n        }), \" the \", _jsx(_components.code, {\n          children: \"resolve\"\n        }), \" function will be called and should\\nreturn the value for the specified id.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If \", _jsx(_components.code, {\n          children: \"existingValues\"\n        }), \" is provided this will be consulted first before calling\\n\", _jsx(_components.code, {\n          children: \"resolve\"\n        }), \". This is useful when you have a list of values that may or\\nmay not have the data you care about. If it's there then the value will\\nbe returned immediately.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"For multiple values see documentation below.\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
        },
        "typeParameter": [
          {
            "id": 674,
            "name": "T",
            "kind": 131072,
            "kindString": "Type parameter",
            "flags": {},
            "anchorId": "T",
            "docFlags": {},
            "tagsByName": {}
          },
          {
            "id": 675,
            "name": "U",
            "kind": 131072,
            "kindString": "Type parameter",
            "flags": {},
            "type": {
              "type": "reference",
              "id": 54,
              "name": "Id"
            },
            "anchorId": "U",
            "docFlags": {},
            "tagsByName": {}
          }
        ],
        "parameters": [
          {
            "id": 676,
            "name": "props",
            "kind": 32768,
            "kindString": "Parameter",
            "flags": {},
            "type": {
              "type": "reference",
              "id": 645,
              "typeArguments": [
                {
                  "type": "reference",
                  "id": 674,
                  "name": "T"
                },
                {
                  "type": "reference",
                  "id": 675,
                  "name": "U"
                }
              ],
              "name": "UseAsyncValuePropsSingle"
            },
            "anchorId": "props",
            "docFlags": {},
            "tagsByName": {}
          }
        ],
        "type": {
          "type": "reference",
          "id": 661,
          "typeArguments": [
            {
              "type": "reference",
              "id": 674,
              "name": "T"
            }
          ],
          "name": "UseAsyncValueReturn"
        },
        "anchorId": "useAsyncValue",
        "docFlags": {},
        "tagsByName": {
          "extract-docs": ""
        }
      },
      {
        "id": 677,
        "name": "useAsyncValue",
        "kind": 4096,
        "kindString": "Call signature",
        "flags": {},
        "comment": {
          "shortText": "Resolve values from an array of ids using an async function.",
          "text": "For the specified array of `ids` the `resolve` function will be called\nand should return an array of the same size with each entry being the resolved\nvalue for the corresponding id.\n\nIf `existingValues` is provided this will be consulted first before calling\n`resolve`. This is useful when you have a list of values that may or\nmay not have the data you care about. If it's there then the values will\nbe returned immediately. Note that if any of the ids are missing from\n`existingValues` then it will be ignored and a call to `resolve` will be made\nrequesting values for all `ids`.\n",
          "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\"\n    }, _provideComponents(), props.components);\n    return _jsx(_components.p, {\n      children: \"Resolve values from an array of ids using an async function.\"\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
          "textMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"For the specified array of \", _jsx(_components.code, {\n          children: \"ids\"\n        }), \" the \", _jsx(_components.code, {\n          children: \"resolve\"\n        }), \" function will be called\\nand should return an array of the same size with each entry being the resolved\\nvalue for the corresponding id.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If \", _jsx(_components.code, {\n          children: \"existingValues\"\n        }), \" is provided this will be consulted first before calling\\n\", _jsx(_components.code, {\n          children: \"resolve\"\n        }), \". This is useful when you have a list of values that may or\\nmay not have the data you care about. If it's there then the values will\\nbe returned immediately. Note that if any of the ids are missing from\\n\", _jsx(_components.code, {\n          children: \"existingValues\"\n        }), \" then it will be ignored and a call to \", _jsx(_components.code, {\n          children: \"resolve\"\n        }), \" will be made\\nrequesting values for all \", _jsx(_components.code, {\n          children: \"ids\"\n        }), \".\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
        },
        "typeParameter": [
          {
            "id": 678,
            "name": "T",
            "kind": 131072,
            "kindString": "Type parameter",
            "flags": {},
            "anchorId": "T",
            "docFlags": {},
            "tagsByName": {}
          },
          {
            "id": 679,
            "name": "U",
            "kind": 131072,
            "kindString": "Type parameter",
            "flags": {},
            "type": {
              "type": "reference",
              "id": 54,
              "name": "Id"
            },
            "anchorId": "U",
            "docFlags": {},
            "tagsByName": {}
          }
        ],
        "parameters": [
          {
            "id": 680,
            "name": "props",
            "kind": 32768,
            "kindString": "Parameter",
            "flags": {},
            "type": {
              "type": "reference",
              "id": 653,
              "typeArguments": [
                {
                  "type": "reference",
                  "id": 678,
                  "name": "T"
                },
                {
                  "type": "reference",
                  "id": 679,
                  "name": "U"
                }
              ],
              "name": "UseAsyncValuePropsMulti"
            },
            "anchorId": "props",
            "docFlags": {},
            "tagsByName": {}
          }
        ],
        "type": {
          "type": "reference",
          "id": 661,
          "typeArguments": [
            {
              "type": "array",
              "elementType": {
                "type": "reference",
                "id": 678,
                "name": "T"
              }
            }
          ],
          "name": "UseAsyncValueReturn"
        },
        "anchorId": "useAsyncValue",
        "docFlags": {},
        "tagsByName": {}
      }
    ],
    "docFlags": {},
    "tagsByName": {
      "extract-docs": ""
    },
    "slug": "util/useAsyncValue"
  },
  "references": {
    "54": {
      "id": 54,
      "name": "Id",
      "kind": 4194304,
      "kindString": "Type alias",
      "flags": {},
      "sources": [
        {
          "fileName": "js-packages/@prestojs/util/src/identifiable.ts",
          "line": 3,
          "character": 12
        }
      ],
      "type": {
        "type": "union",
        "types": [
          {
            "type": "reference",
            "name": "SingleId"
          },
          {
            "type": "reference",
            "name": "CompoundId"
          }
        ]
      },
      "docFlags": {},
      "tagsByName": {},
      "slug": "util/Id",
      "anchorId": "Id"
    },
    "645": {
      "id": 645,
      "name": "UseAsyncValuePropsSingle",
      "kind": 4194304,
      "kindString": "Type alias",
      "flags": {},
      "comment": {
        "tags": [
          {
            "tag": "expand-properties",
            "text": "\n"
          }
        ]
      },
      "sources": [
        {
          "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
          "line": 61,
          "character": 12
        }
      ],
      "typeParameter": [
        {
          "id": 651,
          "name": "T",
          "kind": 131072,
          "kindString": "Type parameter",
          "flags": {},
          "anchorId": "T",
          "docFlags": {},
          "tagsByName": {}
        },
        {
          "id": 652,
          "name": "U",
          "kind": 131072,
          "kindString": "Type parameter",
          "flags": {},
          "type": {
            "type": "reference",
            "id": 54,
            "name": "Id"
          },
          "anchorId": "U",
          "docFlags": {},
          "tagsByName": {}
        }
      ],
      "type": {
        "type": "intersection",
        "types": [
          {
            "type": "reference",
            "typeArguments": [
              {
                "type": "reference",
                "id": 651,
                "name": "T"
              },
              {
                "type": "reference",
                "id": 652,
                "name": "U"
              }
            ],
            "name": "CommonProps"
          },
          {
            "type": "reflection",
            "declaration": {
              "id": 646,
              "name": "UseAsyncValuePropsSingle",
              "kind": 65536,
              "kindString": "Type literal",
              "flags": {},
              "children": [
                {
                  "id": 647,
                  "name": "id",
                  "kind": 1024,
                  "kindString": "Property",
                  "flags": {},
                  "comment": {
                    "shortText": "Single `id` for value to fetch or null if nothing yet to resolve.",
                    "text": "If you need to resolve multiple values use the other form documented\nbelow passing `ids` instead.\n",
                    "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"Single \", _jsx(_components.code, {\n        children: \"id\"\n      }), \" for value to fetch or null if nothing yet to resolve.\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
                    "textMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"If you need to resolve multiple values use the other form documented\\nbelow passing \", _jsx(_components.code, {\n        children: \"ids\"\n      }), \" instead.\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
                  },
                  "sources": [
                    {
                      "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                      "line": 68,
                      "character": 4
                    }
                  ],
                  "type": {
                    "type": "union",
                    "types": [
                      {
                        "type": "reference",
                        "id": 652,
                        "name": "U"
                      },
                      {
                        "type": "literal",
                        "value": null
                      }
                    ]
                  },
                  "anchorId": "Properties-id",
                  "docFlags": {},
                  "tagsByName": {}
                },
                {
                  "id": 648,
                  "name": "resolve",
                  "kind": 2048,
                  "kindString": "Method",
                  "flags": {},
                  "sources": [
                    {
                      "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                      "line": 77,
                      "character": 4
                    }
                  ],
                  "signatures": [
                    {
                      "id": 649,
                      "name": "resolve",
                      "kind": 4096,
                      "kindString": "Call signature",
                      "flags": {},
                      "comment": {
                        "shortText": "Resolve the value for the provided ID. Function is passed a single parameter\nbeing `id`.",
                        "text": "Note that when `trigger` is `DEEP` changes to this function will cause it\nto be called again so you must memoize it (eg. with `useCallback`) if it's\ndefined in your component or hook.\n",
                        "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"Resolve the value for the provided ID. Function is passed a single parameter\\nbeing \", _jsx(_components.code, {\n        children: \"id\"\n      }), \".\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
                        "textMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"Note that when \", _jsx(_components.code, {\n        children: \"trigger\"\n      }), \" is \", _jsx(_components.code, {\n        children: \"DEEP\"\n      }), \" changes to this function will cause it\\nto be called again so you must memoize it (eg. with \", _jsx(_components.code, {\n        children: \"useCallback\"\n      }), \") if it's\\ndefined in your component or hook.\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
                      },
                      "parameters": [
                        {
                          "id": 650,
                          "name": "id",
                          "kind": 32768,
                          "kindString": "Parameter",
                          "flags": {},
                          "type": {
                            "type": "reference",
                            "id": 652,
                            "name": "U"
                          },
                          "anchorId": "id",
                          "docFlags": {},
                          "tagsByName": {}
                        }
                      ],
                      "type": {
                        "type": "reference",
                        "typeArguments": [
                          {
                            "type": "reference",
                            "id": 651,
                            "name": "T"
                          }
                        ],
                        "qualifiedName": "Promise",
                        "package": "typescript",
                        "name": "Promise"
                      },
                      "anchorId": "resolve",
                      "docFlags": {},
                      "tagsByName": {}
                    }
                  ],
                  "docFlags": {},
                  "tagsByName": {}
                }
              ],
              "groups": [
                {
                  "title": "Properties",
                  "kind": 1024,
                  "children": [
                    647
                  ]
                },
                {
                  "title": "Methods",
                  "kind": 2048,
                  "children": [
                    648
                  ]
                }
              ],
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 61,
                  "character": 76
                }
              ],
              "anchorId": "UseAsyncValuePropsSingle",
              "docFlags": {},
              "tagsByName": {}
            }
          }
        ]
      },
      "docFlags": {
        "expandProperties": true
      },
      "tagsByName": {
        "expand-properties": ""
      },
      "slug": "util/UseAsyncValuePropsSingle",
      "anchorId": "UseAsyncValuePropsSingle"
    },
    "653": {
      "id": 653,
      "name": "UseAsyncValuePropsMulti",
      "kind": 4194304,
      "kindString": "Type alias",
      "flags": {},
      "comment": {
        "tags": [
          {
            "tag": "expand-properties",
            "text": "\n"
          }
        ]
      },
      "sources": [
        {
          "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
          "line": 83,
          "character": 12
        }
      ],
      "typeParameter": [
        {
          "id": 659,
          "name": "T",
          "kind": 131072,
          "kindString": "Type parameter",
          "flags": {},
          "anchorId": "T",
          "docFlags": {},
          "tagsByName": {}
        },
        {
          "id": 660,
          "name": "U",
          "kind": 131072,
          "kindString": "Type parameter",
          "flags": {},
          "type": {
            "type": "reference",
            "id": 54,
            "name": "Id"
          },
          "anchorId": "U",
          "docFlags": {},
          "tagsByName": {}
        }
      ],
      "type": {
        "type": "intersection",
        "types": [
          {
            "type": "reference",
            "typeArguments": [
              {
                "type": "reference",
                "id": 659,
                "name": "T"
              },
              {
                "type": "reference",
                "id": 660,
                "name": "U"
              }
            ],
            "name": "CommonProps"
          },
          {
            "type": "reflection",
            "declaration": {
              "id": 654,
              "name": "UseAsyncValuePropsMulti",
              "kind": 65536,
              "kindString": "Type literal",
              "flags": {},
              "children": [
                {
                  "id": 655,
                  "name": "ids",
                  "kind": 1024,
                  "kindString": "Property",
                  "flags": {},
                  "comment": {
                    "shortText": "Array of ids to resolve values for or null if nothing yet to resolve",
                    "text": "If you need to resolve a single value use the other form documented above\npassing `id` instead\n",
                    "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\"\n    }, _provideComponents(), props.components);\n    return _jsx(_components.p, {\n      children: \"Array of ids to resolve values for or null if nothing yet to resolve\"\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
                    "textMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"If you need to resolve a single value use the other form documented above\\npassing \", _jsx(_components.code, {\n        children: \"id\"\n      }), \" instead\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
                  },
                  "sources": [
                    {
                      "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                      "line": 90,
                      "character": 4
                    }
                  ],
                  "type": {
                    "type": "union",
                    "types": [
                      {
                        "type": "array",
                        "elementType": {
                          "type": "reference",
                          "id": 660,
                          "name": "U"
                        }
                      },
                      {
                        "type": "literal",
                        "value": null
                      }
                    ]
                  },
                  "anchorId": "Properties-ids",
                  "docFlags": {},
                  "tagsByName": {}
                },
                {
                  "id": 656,
                  "name": "resolve",
                  "kind": 2048,
                  "kindString": "Method",
                  "flags": {},
                  "sources": [
                    {
                      "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                      "line": 95,
                      "character": 4
                    }
                  ],
                  "signatures": [
                    {
                      "id": 657,
                      "name": "resolve",
                      "kind": 4096,
                      "kindString": "Call signature",
                      "flags": {},
                      "comment": {
                        "shortText": "Resolve the value for the provided IDs. Function is passed a single parameter\nbeing `ids`",
                        "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"Resolve the value for the provided IDs. Function is passed a single parameter\\nbeing \", _jsx(_components.code, {\n        children: \"ids\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
                      },
                      "parameters": [
                        {
                          "id": 658,
                          "name": "ids",
                          "kind": 32768,
                          "kindString": "Parameter",
                          "flags": {},
                          "type": {
                            "type": "array",
                            "elementType": {
                              "type": "reference",
                              "id": 660,
                              "name": "U"
                            }
                          },
                          "anchorId": "ids",
                          "docFlags": {},
                          "tagsByName": {}
                        }
                      ],
                      "type": {
                        "type": "reference",
                        "typeArguments": [
                          {
                            "type": "array",
                            "elementType": {
                              "type": "reference",
                              "id": 659,
                              "name": "T"
                            }
                          }
                        ],
                        "qualifiedName": "Promise",
                        "package": "typescript",
                        "name": "Promise"
                      },
                      "anchorId": "resolve",
                      "docFlags": {},
                      "tagsByName": {}
                    }
                  ],
                  "docFlags": {},
                  "tagsByName": {}
                }
              ],
              "groups": [
                {
                  "title": "Properties",
                  "kind": 1024,
                  "children": [
                    655
                  ]
                },
                {
                  "title": "Methods",
                  "kind": 2048,
                  "children": [
                    656
                  ]
                }
              ],
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 83,
                  "character": 75
                }
              ],
              "anchorId": "UseAsyncValuePropsMulti",
              "docFlags": {},
              "tagsByName": {}
            }
          }
        ]
      },
      "docFlags": {
        "expandProperties": true
      },
      "tagsByName": {
        "expand-properties": ""
      },
      "slug": "util/UseAsyncValuePropsMulti",
      "anchorId": "UseAsyncValuePropsMulti"
    },
    "661": {
      "id": 661,
      "name": "UseAsyncValueReturn",
      "kind": 4194304,
      "kindString": "Type alias",
      "flags": {},
      "sources": [
        {
          "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
          "line": 98,
          "character": 12
        }
      ],
      "typeParameter": [
        {
          "id": 671,
          "name": "T",
          "kind": 131072,
          "kindString": "Type parameter",
          "flags": {},
          "anchorId": "T",
          "docFlags": {},
          "tagsByName": {}
        }
      ],
      "type": {
        "type": "reflection",
        "declaration": {
          "id": 662,
          "name": "UseAsyncValueReturn",
          "kind": 65536,
          "kindString": "Type literal",
          "flags": {},
          "children": [
            {
              "id": 663,
              "name": "error",
              "kind": 1024,
              "kindString": "Property",
              "flags": {},
              "comment": {
                "shortText": "Set to the rejected value of the promise. Only one of `error` and `value` can be set. If\n`isLoading` is true consider this stale (ie. based on _previous_ props). This can be useful\nwhen you want the UI to show the previous value until the next value is ready.",
                "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\",\n      em: \"em\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"Set to the rejected value of the promise. Only one of \", _jsx(_components.code, {\n        children: \"error\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"value\"\n      }), \" can be set. If\\n\", _jsx(_components.code, {\n        children: \"isLoading\"\n      }), \" is true consider this stale (ie. based on \", _jsx(_components.em, {\n        children: \"previous\"\n      }), \" props). This can be useful\\nwhen you want the UI to show the previous value until the next value is ready.\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
              },
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 104,
                  "character": 4
                }
              ],
              "type": {
                "type": "union",
                "types": [
                  {
                    "type": "literal",
                    "value": null
                  },
                  {
                    "type": "reference",
                    "qualifiedName": "Error",
                    "package": "typescript",
                    "name": "Error"
                  }
                ]
              },
              "anchorId": "Properties-error",
              "docFlags": {},
              "tagsByName": {}
            },
            {
              "id": 664,
              "name": "isLoading",
              "kind": 1024,
              "kindString": "Property",
              "flags": {},
              "comment": {
                "shortText": "True while `resolve` call is in progress.",
                "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"True while \", _jsx(_components.code, {\n        children: \"resolve\"\n      }), \" call is in progress.\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
              },
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 108,
                  "character": 4
                }
              ],
              "type": {
                "type": "intrinsic",
                "name": "boolean"
              },
              "anchorId": "Properties-isLoading",
              "docFlags": {},
              "tagsByName": {}
            },
            {
              "id": 665,
              "name": "value",
              "kind": 1024,
              "kindString": "Property",
              "flags": {},
              "comment": {
                "shortText": "The resolved value",
                "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\"\n    }, _provideComponents(), props.components);\n    return _jsx(_components.p, {\n      children: \"The resolved value\"\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
              },
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 112,
                  "character": 4
                }
              ],
              "type": {
                "type": "union",
                "types": [
                  {
                    "type": "reference",
                    "id": 671,
                    "name": "T"
                  },
                  {
                    "type": "literal",
                    "value": null
                  }
                ]
              },
              "anchorId": "Properties-value",
              "docFlags": {},
              "tagsByName": {}
            },
            {
              "id": 669,
              "name": "reset",
              "kind": 2048,
              "kindString": "Method",
              "flags": {},
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 130,
                  "character": 4
                }
              ],
              "signatures": [
                {
                  "id": 670,
                  "name": "reset",
                  "kind": 4096,
                  "kindString": "Call signature",
                  "flags": {},
                  "comment": {
                    "shortText": "When called will set both result and error to null. Will not immediately trigger\na call to the action but subsequent changes to query or paginator will according\nto the value of `trigger`.",
                    "text": "If value is found in `existingValues` then it will still be returned even if\nyou call `reset` - `reset` only clears values that are returned from `resolve`.\n",
                    "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"When called will set both result and error to null. Will not immediately trigger\\na call to the action but subsequent changes to query or paginator will according\\nto the value of \", _jsx(_components.code, {\n        children: \"trigger\"\n      }), \".\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
                    "textMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"If value is found in \", _jsx(_components.code, {\n        children: \"existingValues\"\n      }), \" then it will still be returned even if\\nyou call \", _jsx(_components.code, {\n        children: \"reset\"\n      }), \" - \", _jsx(_components.code, {\n        children: \"reset\"\n      }), \" only clears values that are returned from \", _jsx(_components.code, {\n        children: \"resolve\"\n      }), \".\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
                  },
                  "type": {
                    "type": "intrinsic",
                    "name": "void"
                  },
                  "anchorId": "reset",
                  "docFlags": {},
                  "tagsByName": {}
                }
              ],
              "docFlags": {},
              "tagsByName": {}
            },
            {
              "id": 666,
              "name": "run",
              "kind": 2048,
              "kindString": "Method",
              "flags": {},
              "sources": [
                {
                  "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
                  "line": 121,
                  "character": 4
                }
              ],
              "signatures": [
                {
                  "id": 667,
                  "name": "run",
                  "kind": 4096,
                  "kindString": "Call signature",
                  "flags": {},
                  "comment": {
                    "shortText": "A function to manually trigger the action. If `options.trigger` is `MANUAL`\ncalling this function is the only way to trigger the action.",
                    "text": "This function will return a promise that resolves/rejects to same value\nreturned by `execute`. If `accumulatePages` is set the value returned is\nthe accumulated value.\n",
                    "shortTextMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"A function to manually trigger the action. If \", _jsx(_components.code, {\n        children: \"options.trigger\"\n      }), \" is \", _jsx(_components.code, {\n        children: \"MANUAL\"\n      }), \"\\ncalling this function is the only way to trigger the action.\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n",
                    "textMdx": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_components.p, {\n      children: [\"This function will return a promise that resolves/rejects to same value\\nreturned by \", _jsx(_components.code, {\n        children: \"execute\"\n      }), \". If \", _jsx(_components.code, {\n        children: \"accumulatePages\"\n      }), \" is set the value returned is\\nthe accumulated value.\"]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n"
                  },
                  "parameters": [
                    {
                      "id": 668,
                      "name": "args",
                      "kind": 32768,
                      "kindString": "Parameter",
                      "flags": {
                        "isRest": true
                      },
                      "type": {
                        "type": "array",
                        "elementType": {
                          "type": "intrinsic",
                          "name": "any"
                        }
                      },
                      "anchorId": "args",
                      "docFlags": {},
                      "tagsByName": {}
                    }
                  ],
                  "type": {
                    "type": "reference",
                    "typeArguments": [
                      {
                        "type": "intrinsic",
                        "name": "any"
                      }
                    ],
                    "qualifiedName": "Promise",
                    "package": "typescript",
                    "name": "Promise"
                  },
                  "anchorId": "run",
                  "docFlags": {},
                  "tagsByName": {}
                }
              ],
              "docFlags": {},
              "tagsByName": {}
            }
          ],
          "groups": [
            {
              "title": "Properties",
              "kind": 1024,
              "children": [
                663,
                664,
                665
              ]
            },
            {
              "title": "Methods",
              "kind": 2048,
              "children": [
                669,
                666
              ]
            }
          ],
          "sources": [
            {
              "fileName": "js-packages/@prestojs/util/src/useAsyncValue.ts",
              "line": 98,
              "character": 37
            }
          ],
          "anchorId": "UseAsyncValueReturn",
          "docFlags": {},
          "tagsByName": {}
        }
      },
      "docFlags": {},
      "tagsByName": {},
      "slug": "util/UseAsyncValueReturn",
      "anchorId": "UseAsyncValueReturn"
    }
  },
  "meta": {
    "packageName": "util",
    "permaLink": "useAsyncValue",
    "menuGroup": "default"
  }
}